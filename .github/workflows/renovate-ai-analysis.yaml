# Renovate AI åˆ†æžãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
#
# ã“ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã¯ã€Renovateã®ä¾å­˜é–¢ä¿‚æ›´æ–°PRã«å¯¾ã—ã¦AIã‚’æ´»ç”¨ã—ãŸè‡ªå‹•åˆ†æžã‚’æä¾›ã—ã¾ã™ã€‚
# é–‹ç™ºè€…ãŒãƒžãƒ¼ã‚¸å‰ã«ä¾å­˜é–¢ä¿‚æ›´æ–°ã®å½±éŸ¿ã¨ãƒªã‚¹ã‚¯ã‚’ç†è§£ã™ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚
#
# è²¬å‹™:
# - Renovateã®PRãŒé–‹ã‹ã‚ŒãŸã€ã¾ãŸã¯æ›´æ–°ã•ã‚ŒãŸéš›ã«è‡ªå‹•ã§åˆ†æžã‚’å®Ÿè¡Œ
# - PRæƒ…å ±ï¼ˆå¤‰æ›´å†…å®¹ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã€ä¾å­˜é–¢ä¿‚ï¼‰ã‚’æŠ½å‡º
# - GitHub Models AIã‚’ä½¿ç”¨ã—ã¦ä»¥ä¸‹ã®é …ç›®ã‚’å«ã‚€æ§‹é€ åŒ–ã•ã‚ŒãŸåˆ†æžã‚’æä¾›:
#   * æ›´æ–°ã•ã‚Œã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®æ¦‚è¦
#   * æ½œåœ¨çš„ãªå½±éŸ¿ã¨ãƒªã‚¹ã‚¯ã®è©•ä¾¡
#   * ãƒžãƒ¼ã‚¸å‰ã®æŽ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
#   * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …
# - æ§‹é€ åŒ–ã•ã‚ŒãŸãƒžãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§PRã‚³ãƒ¡ãƒ³ãƒˆã«åˆ†æžçµæžœã‚’æŠ•ç¨¿
# - PRãŒå¤‰æ›´ã•ã‚ŒãŸéš›ã¯æ—¢å­˜ã®åˆ†æžã‚’æ›´æ–°ã—ã¦é‡è¤‡ã‚³ãƒ¡ãƒ³ãƒˆã‚’é˜²æ­¢
# - ãƒ‡ãƒãƒƒã‚°ã¨ç›£è¦–ã®ãŸã‚ã®åŒ…æ‹¬çš„ãªãƒ­ã‚°ã‚’æä¾›
#
# ãƒˆãƒªã‚¬ãƒ¼:
# - kiba-renovate[bot]ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸmainãƒ–ãƒ©ãƒ³ãƒå¯¾è±¡ã®PRã§ã®ã¿å®Ÿè¡Œ
# - PRã®openã¨synchronizeã‚¤ãƒ™ãƒ³ãƒˆã§èµ·å‹•
#
# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£:
# - å®‰å…¨ãªä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã«runner.tempã‚’ä½¿ç”¨
# - ãƒãƒ³ã‚°é˜²æ­¢ã®ãŸã‚ã®é©åˆ‡ãªã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆåˆ¶å¾¡ã‚’å®Ÿè£…
# - æœ€å°æ¨©é™ã®åŽŸå‰‡ã«å¾“ã£ãŸæ¨©é™ãƒ¢ãƒ‡ãƒ«
#
# ä¾å­˜é–¢ä¿‚:
# - GitHub CLI (gh) - PRæ“ä½œç”¨
# - GitHub Models AI - åˆ†æžç”Ÿæˆç”¨
# - jq - Node.jsãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã®JSONå‡¦ç†ç”¨

name: Renovate AI Analysis

on:
  pull_request:
    types: [opened, synchronize]
    branches: [main]

jobs:
  ai-analysis:
    permissions:
      contents: read
      pull-requests: write
      models: read

    if: startsWith(github.head_ref, 'renovate/') && github.actor == 'kiba-renovate[bot]'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          filter: blob:none

      - name: Get PR details
        id: pr-details
        timeout-minutes: 2
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          echo "ðŸ” Starting PR details collection for PR #$PR_NUMBER"
          echo "ðŸ“ PR Title: $PR_TITLE"
          
          # Get PR information
          echo "ðŸ“‹ Fetching PR body..."
          PR_BODY=$(gh pr view $PR_NUMBER --json body --jq '.body')
          echo "âœ… PR body fetched (${#PR_BODY} characters)"
          
          # Get changed files
          echo "ðŸ“ Fetching changed files..."
          CHANGED_FILES=$(gh pr diff $PR_NUMBER --name-only)
          echo "âœ… Found $(echo "$CHANGED_FILES" | wc -l) changed files"

          # Get package.json changes if any
          echo "ðŸ“¦ Checking for package changes..."
          PACKAGE_CHANGES=""
          if echo "$CHANGED_FILES" | grep -q "package.json\|package-lock.json"; then
            echo "ðŸ“¦ Package files detected, fetching changes..."
            PACKAGE_CHANGES=$(gh pr diff $PR_NUMBER -- package.json package-lock.json || echo "No package changes visible")
            echo "âœ… Package changes fetched (${#PACKAGE_CHANGES} characters)"
          else
            echo "â„¹ï¸  No package files in changes"
          fi
          
          # Get project context information
          echo "ðŸ” Detecting project type..."
          PROJECT_TYPE="Unknown"
          MAIN_DEPENDENCIES=""
          
          if [ -f "package.json" ]; then
            PROJECT_TYPE="Node.js/JavaScript"
            echo "âœ… Detected Node.js/JavaScript project"
            # Extract key dependencies for context
            MAIN_DEPENDENCIES=$(jq -r '.dependencies // {} | keys | join(", ")' package.json 2>/dev/null | head -c 200)
            echo "ðŸ“‹ Found $(echo "$MAIN_DEPENDENCIES" | tr ',' '\n' | wc -l 2>/dev/null || echo "0") main dependencies"
          elif [ -f "Cargo.toml" ]; then
            PROJECT_TYPE="Rust"
            echo "âœ… Detected Rust project"
          elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
            PROJECT_TYPE="Python"
            echo "âœ… Detected Python project"
          elif [ -f "go.mod" ]; then
            PROJECT_TYPE="Go"
            echo "âœ… Detected Go project"
          else
            echo "âš ï¸  Could not determine project type"
          fi
          
          # Get README snippet for project context (first 500 chars)
          echo "ðŸ“– Reading project context from README..."
          README_CONTEXT=""
          if [ -f "README.md" ]; then
            README_CONTEXT=$(head -c 500 README.md | tr '\n' ' ')
            echo "âœ… README context captured (${#README_CONTEXT} characters)"
          else
            echo "â„¹ï¸  No README.md found"
          fi
          
          # Use GitHub Actions standard temp directory
          echo "ðŸ’¾ Preparing temporary files for AI analysis..."
          TEMP_DIR="${{ runner.temp }}/ai-analysis"
          mkdir -p "$TEMP_DIR"
          echo "âœ… Created temp directory: $TEMP_DIR"
          
          # Save to files for AI analysis
          echo "$PR_TITLE" > "$TEMP_DIR/pr-title.txt"
          echo "$PR_BODY" > "$TEMP_DIR/pr-body.txt"
          echo "$CHANGED_FILES" > "$TEMP_DIR/changed-files.txt"
          echo "$PACKAGE_CHANGES" > "$TEMP_DIR/package-changes.txt"
          echo "$PROJECT_TYPE" > "$TEMP_DIR/project-type.txt"
          echo "$MAIN_DEPENDENCIES" > "$TEMP_DIR/main-dependencies.txt"
          echo "$README_CONTEXT" > "$TEMP_DIR/readme-context.txt"
          echo "âœ… All context files saved to temp directory"
          
          # Export temp directory for next step
          echo "TEMP_DIR=$TEMP_DIR" >> $GITHUB_OUTPUT
          
          # Determine update type and severity with improved logic
          echo "ðŸ” Analyzing update type from PR title..."
          UPDATE_TYPE="patch"
          SEVERITY="low"
          
          # Check for major updates (more comprehensive patterns)
          if [[ "$PR_TITLE" =~ (major|breaking|v[0-9]+\.0\.0|major\ version|breaking\ change) ]]; then
            UPDATE_TYPE="major"
            SEVERITY="high"
            echo "ðŸš¨ Detected MAJOR update (high severity)"
          # Check for minor updates (improved patterns)
          elif [[ "$PR_TITLE" =~ (minor|feature|v[0-9]+\.[1-9][0-9]*\.0|minor\ version) ]]; then
            UPDATE_TYPE="minor"
            SEVERITY="medium"
            echo "âš ï¸  Detected MINOR update (medium severity)"
          # Check for patch updates (specific patterns)
          elif [[ "$PR_TITLE" =~ (patch|fix|bug|security|v[0-9]+\.[0-9]+\.[1-9][0-9]*|patch\ version) ]]; then
            UPDATE_TYPE="patch"
            SEVERITY="low"
            echo "âœ… Detected PATCH update (low severity)"
          # Additional checks for dev dependencies (lower severity)
          elif [[ "$PR_TITLE" =~ (devDependencies|dev-dependencies|@types/) ]]; then
            UPDATE_TYPE="dev"
            SEVERITY="low"
            echo "ðŸ”§ Detected DEV DEPENDENCY update (low severity)"
          # Check for security updates (higher priority)
          elif [[ "$PR_TITLE" =~ (security|vulnerability|CVE-|GHSA-) ]]; then
            UPDATE_TYPE="security"
            SEVERITY="high"
            echo "ðŸ”’ Detected SECURITY update (high severity)"
          else
            echo "â“ Could not determine specific update type, defaulting to PATCH (low severity)"
          fi
          
          echo "update-type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
          echo "severity=$SEVERITY" >> $GITHUB_OUTPUT
          
          echo "ðŸŽ¯ PR details collection completed successfully"

      - name: AI Analysis of Changes
        id: ai-analysis
        timeout-minutes: 5
        uses: actions/ai-inference@v1
        with:
          model: openai/gpt-4o
          prompt: |
            You are a senior software engineer reviewing a dependency update PR created by Renovate.
            
            Analyze the following PR details and provide a structured response:
            
            **PR Title:** ${{ github.event.pull_request.title }}
            
            **PR Description:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/pr-body.txt)
            
            **Changed Files:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/changed-files.txt)
            
            **Package Changes:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/package-changes.txt)
            
            **Project Type:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/project-type.txt)
            
            **Main Dependencies:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/main-dependencies.txt)
            
            **Project Context:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/readme-context.txt)
            
            **Update Type:** ${{ steps.pr-details.outputs.update-type }}
            
            Please provide your analysis in the following structured format (use plain text without markdown formatting):
            
            SUMMARY: [Brief summary of what packages are being updated]
            IMPACT: [Potential impact and risks, especially for major updates]
            ACTIONS: [Recommended actions before merging]
            SECURITY: [Any security considerations]
            
            Keep each section concise and actionable. Use plain text only without any markdown formatting.

      - name: Comment AI Analysis
        timeout-minutes: 3
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ’¬ Starting comment creation process..."
          
          # Check for existing AI analysis comments to prevent duplicates
          echo "ðŸ” Checking for existing AI analysis comments..."
          EXISTING_COMMENT_ID=$(gh pr view ${{ github.event.pull_request.number }} --json comments --jq '.comments[] | select(.body | contains("ðŸ¤– AI Analysis Summary")) | .id' | head -1)
          
          if [ -n "$EXISTING_COMMENT_ID" ]; then
            echo "âœ… Found existing AI analysis comment (ID: $EXISTING_COMMENT_ID), will update it"
            UPDATE_EXISTING=true
          else
            echo "â„¹ï¸  No existing AI analysis comment found, will create new one"
            UPDATE_EXISTING=false
          fi
          
          # Parse AI response into structured variables with error handling
          echo "ðŸ¤– Processing AI analysis response..."
          AI_RESPONSE="${{ steps.ai-analysis.outputs.response }}"
          echo "ðŸ“ AI response length: ${#AI_RESPONSE} characters"
          
          # Check if AI response is empty or null
          if [ -z "$AI_RESPONSE" ] || [ "$AI_RESPONSE" = "null" ]; then
            echo "âš ï¸  Warning: AI response is empty or null, using fallback content"
            AI_RESPONSE="SUMMARY: ä¾å­˜é–¢ä¿‚ã®æ›´æ–°
          IMPACT: AIåˆ†æžãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã§ã—ãŸ
          ACTIONS: æ‰‹å‹•ã§PRã®å†…å®¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„
          SECURITY: æ‰‹å‹•ã§ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å½±éŸ¿ã‚’ç¢ºèªã—ã¦ãã ã•ã„"
          else
            echo "âœ… AI response received successfully"
          fi
          
          # Extract each section using grep and sed with error handling
          echo "ðŸ” Parsing AI response sections..."
          SUMMARY=$(echo "$AI_RESPONSE" | grep "^SUMMARY:" | sed 's/^SUMMARY: *//' | head -1 | tr -d '\r')
          IMPACT=$(echo "$AI_RESPONSE" | grep "^IMPACT:" | sed 's/^IMPACT: *//' | head -1 | tr -d '\r')
          ACTIONS=$(echo "$AI_RESPONSE" | grep "^ACTIONS:" | sed 's/^ACTIONS: *//' | head -1 | tr -d '\r')
          SECURITY=$(echo "$AI_RESPONSE" | grep "^SECURITY:" | sed 's/^SECURITY: *//' | head -1 | tr -d '\r')
          
          echo "ðŸ“‹ Extracted sections:"
          echo "  - Summary: ${#SUMMARY} chars"
          echo "  - Impact: ${#IMPACT} chars"
          echo "  - Actions: ${#ACTIONS} chars"
          echo "  - Security: ${#SECURITY} chars"
          
          # Set default values if sections are empty or contain only whitespace
          SUMMARY=$(echo "$SUMMARY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          IMPACT=$(echo "$IMPACT" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          ACTIONS=$(echo "$ACTIONS" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          SECURITY=$(echo "$SECURITY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          SUMMARY=${SUMMARY:-"ä¾å­˜é–¢ä¿‚ã®æ›´æ–°"}
          IMPACT=${IMPACT:-"å½±éŸ¿ã®è©³ç´°ã¯ä¸æ˜Ž"}
          ACTIONS=${ACTIONS:-"é€šå¸¸ã®ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ç¢ºèª"}
          SECURITY=${SECURITY:-"ç‰¹åˆ¥ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …ã¯ã‚ã‚Šã¾ã›ã‚“"}
          
          # Escape special characters for sed
          SUMMARY=$(echo "$SUMMARY" | sed 's/[[\.*^$()+?{|]/\\&/g')
          IMPACT=$(echo "$IMPACT" | sed 's/[[\.*^$()+?{|]/\\&/g')
          ACTIONS=$(echo "$ACTIONS" | sed 's/[[\.*^$()+?{|]/\\&/g')
          SECURITY=$(echo "$SECURITY" | sed 's/[[\.*^$()+?{|]/\\&/g')
          
          # Create temporary file for comment using GitHub Actions temp directory
          TEMP_COMMENT_FILE="${{ runner.temp }}/ai-comment-final.md"
          
          # Create markdown comment using template
          cat > "$TEMP_COMMENT_FILE" << 'EOF'
          ## ðŸ¤– AI Analysis Summary
          
          ### ðŸ“‹ æ›´æ–°æ¦‚è¦
          SUMMARY_PLACEHOLDER
          
          ### âš ï¸ æ½œåœ¨çš„ãªå½±éŸ¿ã¨ãƒªã‚¹ã‚¯
          IMPACT_PLACEHOLDER
          
          ### âœ… æŽ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
          ACTIONS_PLACEHOLDER
          
          ### ðŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …
          SECURITY_PLACEHOLDER
          
          ---
          *Generated by GitHub Models AI*
          EOF
          
          # Replace placeholders with actual content (using | as delimiter to avoid conflicts)
          sed -i "s|SUMMARY_PLACEHOLDER|${SUMMARY}|g" "$TEMP_COMMENT_FILE"
          sed -i "s|IMPACT_PLACEHOLDER|${IMPACT}|g" "$TEMP_COMMENT_FILE"
          sed -i "s|ACTIONS_PLACEHOLDER|${ACTIONS}|g" "$TEMP_COMMENT_FILE"
          sed -i "s|SECURITY_PLACEHOLDER|${SECURITY}|g" "$TEMP_COMMENT_FILE"
          
          # Verify the comment file was created successfully
          if [ ! -f "$TEMP_COMMENT_FILE" ] || [ ! -s "$TEMP_COMMENT_FILE" ]; then
            echo "Error: Failed to create comment file or file is empty"
            echo "Creating fallback comment..."
            cat > "$TEMP_COMMENT_FILE" << 'EOF'
          ## ðŸ¤– AI Analysis Summary
          
          AIåˆ†æžã®ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§PRã®å†…å®¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚
          
          ---
          *Generated by GitHub Models AI*
          EOF
          fi
          
          # Post comment or update existing comment with error handling
          echo "ðŸ’¬ Publishing comment to PR..."
          if [ "$UPDATE_EXISTING" = "true" ]; then
            echo "ðŸ”„ Updating existing comment (ID: $EXISTING_COMMENT_ID)"
            if ! gh api \
              --method PATCH \
              --header "Accept: application/vnd.github+json" \
              --header "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/issues/comments/$EXISTING_COMMENT_ID \
              --field body="$(cat "$TEMP_COMMENT_FILE")"; then
              echo "âŒ Error: Failed to update existing PR comment"
              exit 1
            fi
            echo "âœ… Successfully updated existing comment"
          else
            echo "âž• Creating new comment"
            if ! gh pr comment ${{ github.event.pull_request.number }} \
              --body-file "$TEMP_COMMENT_FILE" \
              --repo ${{ github.repository }}; then
              echo "âŒ Error: Failed to post PR comment"
              exit 1
            fi
            echo "âœ… Successfully created new comment"
          fi
          
          echo "ðŸŽ‰ AI analysis comment published successfully!"

      - uses: Kesin11/actions-timeline@3046833d9aacfd7745c5264b7f3af851c3e2a619 # v2.2.1
