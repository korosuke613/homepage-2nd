# Renovate AI ÂàÜÊûê„ÉØ„Éº„ÇØ„Éï„É≠„Éº
#
# „Åì„ÅÆ„ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÅØ„ÄÅRenovate„ÅÆ‰æùÂ≠òÈñ¢‰øÇÊõ¥Êñ∞PR„Å´ÂØæ„Åó„Å¶AI„ÇíÊ¥ªÁî®„Åó„ÅüËá™ÂãïÂàÜÊûê„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ
# ÈñãÁô∫ËÄÖ„Åå„Éû„Éº„Ç∏Ââç„Å´‰æùÂ≠òÈñ¢‰øÇÊõ¥Êñ∞„ÅÆÂΩ±Èüø„Å®„É™„Çπ„ÇØ„ÇíÁêÜËß£„Åô„Çã„ÅÆ„Å´ÂΩπÁ´ã„Å°„Åæ„Åô„ÄÇ
#
# Ë≤¨Âãô:
# - Renovate„ÅÆPR„ÅåÈñã„Åã„Çå„Åü„ÄÅ„Åæ„Åü„ÅØÊõ¥Êñ∞„Åï„Çå„ÅüÈöõ„Å´Ëá™Âãï„ÅßÂàÜÊûê„ÇíÂÆüË°å
# - PRÊÉÖÂ†±ÔºàÂ§âÊõ¥ÂÜÖÂÆπ„ÄÅ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Çø„Ç§„Éó„ÄÅ‰æùÂ≠òÈñ¢‰øÇÔºâ„ÇíÊäΩÂá∫
# - GitHub Models AI„Çí‰ΩøÁî®„Åó„Å¶‰ª•‰∏ã„ÅÆÈ†ÖÁõÆ„ÇíÂê´„ÇÄÊßãÈÄ†Âåñ„Åï„Çå„ÅüÂàÜÊûê„ÇíÊèê‰æõ:
#   * Êõ¥Êñ∞„Åï„Çå„Çã„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆÊ¶ÇË¶Å
#   * ÊΩúÂú®ÁöÑ„Å™ÂΩ±Èüø„Å®„É™„Çπ„ÇØ„ÅÆË©ï‰æ°
#   * „Éû„Éº„Ç∏Ââç„ÅÆÊé®Â•®„Ç¢„ÇØ„Ç∑„Éß„É≥
#   * „Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÄÉÊÖÆ‰∫ãÈ†Ö
# - ÊßãÈÄ†Âåñ„Åï„Çå„Åü„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅßPR„Ç≥„É°„É≥„Éà„Å´ÂàÜÊûêÁµêÊûú„ÇíÊäïÁ®ø
# - PR„ÅåÂ§âÊõ¥„Åï„Çå„ÅüÈöõ„ÅØÊó¢Â≠ò„ÅÆÂàÜÊûê„ÇíÊõ¥Êñ∞„Åó„Å¶ÈáçË§á„Ç≥„É°„É≥„Éà„ÇíÈò≤Ê≠¢
# - „Éá„Éê„ÉÉ„Ç∞„Å®Áõ£Ë¶ñ„ÅÆ„Åü„ÇÅ„ÅÆÂåÖÊã¨ÁöÑ„Å™„É≠„Ç∞„ÇíÊèê‰æõ
#
# „Éà„É™„Ç¨„Éº:
# - kiba-renovate[bot]„Å´„Çà„Å£„Å¶‰ΩúÊàê„Åï„Çå„Åümain„Éñ„É©„É≥„ÉÅÂØæË±°„ÅÆPR„Åß„ÅÆ„ÅøÂÆüË°å
# - PR„ÅÆopen„Å®synchronize„Ç§„Éô„É≥„Éà„ÅßËµ∑Âãï
#
# „Çª„Ç≠„É•„É™„ÉÜ„Ç£:
# - ÂÆâÂÖ®„Å™‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´Âá¶ÁêÜ„Å´runner.temp„Çí‰ΩøÁî®
# - „Éè„É≥„Ç∞Èò≤Ê≠¢„ÅÆ„Åü„ÇÅ„ÅÆÈÅ©Âàá„Å™„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÂà∂Âæ°„ÇíÂÆüË£Ö
# - ÊúÄÂ∞èÊ®©Èôê„ÅÆÂéüÂâá„Å´Âæì„Å£„ÅüÊ®©Èôê„É¢„Éá„É´
#
# ‰æùÂ≠òÈñ¢‰øÇ:
# - GitHub CLI (gh) - PRÊìç‰ΩúÁî®
# - GitHub Models AI - ÂàÜÊûêÁîüÊàêÁî®
# - jq - Node.js„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß„ÅÆJSONÂá¶ÁêÜÁî®

name: Renovate AI Analysis

on:
  pull_request:
    types: [opened, synchronize]
    branches: [main]

jobs:
  ai-analysis:
    permissions:
      contents: read
      pull-requests: write
      models: read

    if: startsWith(github.head_ref, 'renovate/') && github.actor == 'kiba-renovate[bot]'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          filter: blob:none

      - name: Get PR details
        id: pr-details
        timeout-minutes: 2
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          echo "üîç Starting PR details collection for PR #$PR_NUMBER"
          echo "üìù PR Title: $PR_TITLE"
          
          # Get PR information
          echo "üìã Fetching PR body..."
          PR_BODY=$(gh pr view $PR_NUMBER --json body --jq '.body')
          echo "‚úÖ PR body fetched (${#PR_BODY} characters)"
          
          # Get changed files
          echo "üìÅ Fetching changed files..."
          CHANGED_FILES=$(gh pr diff $PR_NUMBER --name-only)
          echo "‚úÖ Found $(echo "$CHANGED_FILES" | wc -l) changed files"

          # Get package.json changes if any
          echo "üì¶ Checking for package changes..."
          PACKAGE_CHANGES=""
          if echo "$CHANGED_FILES" | grep -q "package.json\|package-lock.json"; then
            echo "üì¶ Package files detected, fetching changes..."
            PACKAGE_CHANGES=$(gh pr diff $PR_NUMBER -- package.json package-lock.json || echo "No package changes visible")
            echo "‚úÖ Package changes fetched (${#PACKAGE_CHANGES} characters)"
          else
            echo "‚ÑπÔ∏è  No package files in changes"
          fi
          
          # Get project context information
          echo "üîç Detecting project type..."
          PROJECT_TYPE="Unknown"
          MAIN_DEPENDENCIES=""
          
          if [ -f "package.json" ]; then
            PROJECT_TYPE="Node.js/JavaScript"
            echo "‚úÖ Detected Node.js/JavaScript project"
            # Extract key dependencies for context
            MAIN_DEPENDENCIES=$(jq -r '.dependencies // {} | keys | join(", ")' package.json 2>/dev/null | head -c 200)
            echo "üìã Found $(echo "$MAIN_DEPENDENCIES" | tr ',' '\n' | wc -l 2>/dev/null || echo "0") main dependencies"
          elif [ -f "Cargo.toml" ]; then
            PROJECT_TYPE="Rust"
            echo "‚úÖ Detected Rust project"
          elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
            PROJECT_TYPE="Python"
            echo "‚úÖ Detected Python project"
          elif [ -f "go.mod" ]; then
            PROJECT_TYPE="Go"
            echo "‚úÖ Detected Go project"
          else
            echo "‚ö†Ô∏è  Could not determine project type"
          fi
          
          # Get README snippet for project context (first 500 chars)
          echo "üìñ Reading project context from README..."
          README_CONTEXT=""
          if [ -f "README.md" ]; then
            README_CONTEXT=$(head -c 500 README.md | tr '\n' ' ')
            echo "‚úÖ README context captured (${#README_CONTEXT} characters)"
          else
            echo "‚ÑπÔ∏è  No README.md found"
          fi
          
          # Use GitHub Actions standard temp directory
          echo "üíæ Preparing temporary files for AI analysis..."
          TEMP_DIR="${{ runner.temp }}/ai-analysis"
          mkdir -p "$TEMP_DIR"
          echo "‚úÖ Created temp directory: $TEMP_DIR"
          
          # Save to files for AI analysis
          echo "$PR_TITLE" > "$TEMP_DIR/pr-title.txt"
          echo "$PR_BODY" > "$TEMP_DIR/pr-body.txt"
          echo "$CHANGED_FILES" > "$TEMP_DIR/changed-files.txt"
          echo "$PACKAGE_CHANGES" > "$TEMP_DIR/package-changes.txt"
          echo "$PROJECT_TYPE" > "$TEMP_DIR/project-type.txt"
          echo "$MAIN_DEPENDENCIES" > "$TEMP_DIR/main-dependencies.txt"
          echo "$README_CONTEXT" > "$TEMP_DIR/readme-context.txt"
          echo "‚úÖ All context files saved to temp directory"
          
          # Export temp directory for next step
          echo "TEMP_DIR=$TEMP_DIR" >> $GITHUB_OUTPUT
          
          # Determine update type and severity with improved logic
          echo "üîç Analyzing update type from PR title..."
          UPDATE_TYPE="patch"
          SEVERITY="low"
          
          # Check for major updates (more comprehensive patterns)
          if [[ "$PR_TITLE" =~ (major|breaking|v[0-9]+\.0\.0|major\ version|breaking\ change) ]]; then
            UPDATE_TYPE="major"
            SEVERITY="high"
            echo "üö® Detected MAJOR update (high severity)"
          # Check for minor updates (improved patterns)
          elif [[ "$PR_TITLE" =~ (minor|feature|v[0-9]+\.[1-9][0-9]*\.0|minor\ version) ]]; then
            UPDATE_TYPE="minor"
            SEVERITY="medium"
            echo "‚ö†Ô∏è  Detected MINOR update (medium severity)"
          # Check for patch updates (specific patterns)
          elif [[ "$PR_TITLE" =~ (patch|fix|bug|security|v[0-9]+\.[0-9]+\.[1-9][0-9]*|patch\ version) ]]; then
            UPDATE_TYPE="patch"
            SEVERITY="low"
            echo "‚úÖ Detected PATCH update (low severity)"
          # Additional checks for dev dependencies (lower severity)
          elif [[ "$PR_TITLE" =~ (devDependencies|dev-dependencies|@types/) ]]; then
            UPDATE_TYPE="dev"
            SEVERITY="low"
            echo "üîß Detected DEV DEPENDENCY update (low severity)"
          # Check for security updates (higher priority)
          elif [[ "$PR_TITLE" =~ (security|vulnerability|CVE-|GHSA-) ]]; then
            UPDATE_TYPE="security"
            SEVERITY="high"
            echo "üîí Detected SECURITY update (high severity)"
          else
            echo "‚ùì Could not determine specific update type, defaulting to PATCH (low severity)"
          fi
          
          echo "update-type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
          echo "severity=$SEVERITY" >> $GITHUB_OUTPUT
          
          echo "üéØ PR details collection completed successfully"

      - name: AI Analysis of Changes
        id: ai-analysis
        timeout-minutes: 5
        uses: actions/ai-inference@v1
        with:
          model: openai/gpt-4o
          prompt: |
            You are a senior software engineer reviewing a dependency update PR created by Renovate.
            
            Analyze the following PR details and provide a structured response:
            
            **PR Title:** ${{ github.event.pull_request.title }}
            
            **PR Description:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/pr-body.txt)
            
            **Changed Files:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/changed-files.txt)
            
            **Package Changes:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/package-changes.txt)
            
            **Project Type:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/project-type.txt)
            
            **Main Dependencies:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/main-dependencies.txt)
            
            **Project Context:** $(cat ${{ steps.pr-details.outputs.temp-dir }}/readme-context.txt)
            
            **Update Type:** ${{ steps.pr-details.outputs.update-type }}
            
            Please provide your analysis in the following structured format (use plain text without markdown formatting):
            
            SUMMARY: [Brief summary of what packages are being updated]
            IMPACT: [Potential impact and risks, especially for major updates]
            ACTIONS: [Recommended actions before merging]
            SECURITY: [Any security considerations]
            
            Keep each section concise and actionable. Use plain text only without any markdown formatting.

      - name: Comment AI Analysis
        timeout-minutes: 3
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üí¨ Starting comment creation process..."
          
          # Check for existing AI analysis comments to prevent duplicates
          echo "üîç Checking for existing AI analysis comments..."
          EXISTING_COMMENT_ID=$(gh pr view ${{ github.event.pull_request.number }} --json comments --jq '.comments[] | select(.body | contains("ü§ñ AI Analysis Summary")) | .id' | head -1)
          
          if [ -n "$EXISTING_COMMENT_ID" ]; then
            echo "‚úÖ Found existing AI analysis comment (ID: $EXISTING_COMMENT_ID), will update it"
            UPDATE_EXISTING=true
          else
            echo "‚ÑπÔ∏è  No existing AI analysis comment found, will create new one"
            UPDATE_EXISTING=false
          fi
          
          # Parse AI response into structured variables with error handling
          echo "ü§ñ Processing AI analysis response..."
          AI_RESPONSE="${{ steps.ai-analysis.outputs.response }}"
          echo "üìù AI response length: ${#AI_RESPONSE} characters"
          
          # Check if AI response is empty or null
          if [ -z "$AI_RESPONSE" ] || [ "$AI_RESPONSE" = "null" ]; then
            echo "‚ö†Ô∏è  Warning: AI response is empty or null, using fallback content"
            AI_RESPONSE="SUMMARY: ‰æùÂ≠òÈñ¢‰øÇ„ÅÆÊõ¥Êñ∞
          IMPACT: AIÂàÜÊûê„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü
          ACTIONS: ÊâãÂãï„ÅßPR„ÅÆÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ
          SECURITY: ÊâãÂãï„Åß„Çª„Ç≠„É•„É™„ÉÜ„Ç£ÂΩ±Èüø„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ"
          else
            echo "‚úÖ AI response received successfully"
          fi
          
          # Extract each section using grep and sed with error handling
          echo "üîç Parsing AI response sections..."
          SUMMARY=$(echo "$AI_RESPONSE" | grep "^SUMMARY:" | sed 's/^SUMMARY: *//' | head -1 | tr -d '\r')
          IMPACT=$(echo "$AI_RESPONSE" | grep "^IMPACT:" | sed 's/^IMPACT: *//' | head -1 | tr -d '\r')
          ACTIONS=$(echo "$AI_RESPONSE" | grep "^ACTIONS:" | sed 's/^ACTIONS: *//' | head -1 | tr -d '\r')
          SECURITY=$(echo "$AI_RESPONSE" | grep "^SECURITY:" | sed 's/^SECURITY: *//' | head -1 | tr -d '\r')
          
          echo "üìã Extracted sections:"
          echo "  - Summary: ${#SUMMARY} chars"
          echo "  - Impact: ${#IMPACT} chars"
          echo "  - Actions: ${#ACTIONS} chars"
          echo "  - Security: ${#SECURITY} chars"
          
          # Set default values if sections are empty or contain only whitespace
          SUMMARY=$(echo "$SUMMARY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          IMPACT=$(echo "$IMPACT" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          ACTIONS=$(echo "$ACTIONS" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          SECURITY=$(echo "$SECURITY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          SUMMARY=${SUMMARY:-"‰æùÂ≠òÈñ¢‰øÇ„ÅÆÊõ¥Êñ∞"}
          IMPACT=${IMPACT:-"ÂΩ±Èüø„ÅÆË©≥Á¥∞„ÅØ‰∏çÊòé"}
          ACTIONS=${ACTIONS:-"ÈÄöÂ∏∏„ÅÆ„ÉÜ„Çπ„Éà„ÇíÂÆüË°å„Åó„Å¶Á¢∫Ë™ç"}
          SECURITY=${SECURITY:-"ÁâπÂà•„Å™„Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÄÉÊÖÆ‰∫ãÈ†Ö„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì"}
          
          # Escape special characters for sed
          SUMMARY=$(echo "$SUMMARY" | sed 's/[[\.*^$()+?{|]/\\&/g')
          IMPACT=$(echo "$IMPACT" | sed 's/[[\.*^$()+?{|]/\\&/g')
          ACTIONS=$(echo "$ACTIONS" | sed 's/[[\.*^$()+?{|]/\\&/g')
          SECURITY=$(echo "$SECURITY" | sed 's/[[\.*^$()+?{|]/\\&/g')
          
          # Create temporary file for comment using GitHub Actions temp directory
          TEMP_COMMENT_FILE="${{ runner.temp }}/ai-comment-final.md"
          
          # Create markdown comment using template
          cat > "$TEMP_COMMENT_FILE" << 'EOF'
          ## ü§ñ AI Analysis Summary
          
          ### üìã Êõ¥Êñ∞Ê¶ÇË¶Å
          SUMMARY_PLACEHOLDER
          
          ### ‚ö†Ô∏è ÊΩúÂú®ÁöÑ„Å™ÂΩ±Èüø„Å®„É™„Çπ„ÇØ
          IMPACT_PLACEHOLDER
          
          ### ‚úÖ Êé®Â•®„Ç¢„ÇØ„Ç∑„Éß„É≥
          ACTIONS_PLACEHOLDER
          
          ### üîí „Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÄÉÊÖÆ‰∫ãÈ†Ö
          SECURITY_PLACEHOLDER
          
          ---
          *Generated by GitHub Models AI*
          EOF
          
          # Replace placeholders with actual content (using | as delimiter to avoid conflicts)
          sed -i "s|SUMMARY_PLACEHOLDER|${SUMMARY}|g" "$TEMP_COMMENT_FILE"
          sed -i "s|IMPACT_PLACEHOLDER|${IMPACT}|g" "$TEMP_COMMENT_FILE"
          sed -i "s|ACTIONS_PLACEHOLDER|${ACTIONS}|g" "$TEMP_COMMENT_FILE"
          sed -i "s|SECURITY_PLACEHOLDER|${SECURITY}|g" "$TEMP_COMMENT_FILE"
          
          # Verify the comment file was created successfully
          if [ ! -f "$TEMP_COMMENT_FILE" ] || [ ! -s "$TEMP_COMMENT_FILE" ]; then
            echo "Error: Failed to create comment file or file is empty"
            echo "Creating fallback comment..."
            cat > "$TEMP_COMMENT_FILE" << 'EOF'
          ## ü§ñ AI Analysis Summary
          
          AIÂàÜÊûê„ÅÆÁîüÊàê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÊâãÂãï„ÅßPR„ÅÆÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
          
          ---
          *Generated by GitHub Models AI*
          EOF
          fi
          
          # Post comment or update existing comment with error handling
          echo "üí¨ Publishing comment to PR..."
          if [ "$UPDATE_EXISTING" = "true" ]; then
            echo "üîÑ Updating existing comment (ID: $EXISTING_COMMENT_ID)"
            if ! gh api \
              --method PATCH \
              --header "Accept: application/vnd.github+json" \
              --header "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/issues/comments/$EXISTING_COMMENT_ID \
              --field body="$(cat "$TEMP_COMMENT_FILE")"; then
              echo "‚ùå Error: Failed to update existing PR comment"
              exit 1
            fi
            echo "‚úÖ Successfully updated existing comment"
          else
            echo "‚ûï Creating new comment"
            if ! gh pr comment ${{ github.event.pull_request.number }} \
              --body-file "$TEMP_COMMENT_FILE" \
              --repo ${{ github.repository }}; then
              echo "‚ùå Error: Failed to post PR comment"
              exit 1
            fi
            echo "‚úÖ Successfully created new comment"
          fi
          
          echo "üéâ AI analysis comment published successfully!"

      - uses: Kesin11/actions-timeline@3046833d9aacfd7745c5264b7f3af851c3e2a619 # v2.2.1
