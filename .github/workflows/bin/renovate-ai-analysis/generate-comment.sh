#!/bin/bash
set -euo pipefail

# Generate Comment Script for Renovate AI Analysis
# Creates structured markdown comment from AI analysis results

# Source utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/utils/logging.sh"
source "${SCRIPT_DIR}/utils/file-utils.sh"
source "${SCRIPT_DIR}/utils/validation.sh"

# Comment template
readonly COMMENT_TEMPLATE='## 🤖 AI Analysis Summary

### 📋 更新概要
SUMMARY_PLACEHOLDER

### ⚠️ 潜在的な影響とリスク
IMPACT_PLACEHOLDER

### ✅ 推奨アクション
ACTIONS_PLACEHOLDER

### 🔒 セキュリティ考慮事項
SECURITY_PLACEHOLDER

---
*Generated by GitHub Models AI*'

# Main function
main() {
    local temp_dir="$1"
    
    log_comment "Starting markdown comment generation..."
    
    # Validate inputs
    validate_inputs "${temp_dir}"
    
    # Load AI analysis sections
    load_ai_sections "${temp_dir}"
    
    # Generate comment file
    generate_comment_file "${temp_dir}"
    
    # Validate generated comment
    validate_comment_file "${temp_dir}"
    
    log_complete "Comment generation completed successfully"
}

# Validate input parameters and required files
validate_inputs() {
    local temp_dir="$1"
    
    if [[ ! -d "${temp_dir}" ]]; then
        log_error "Temporary directory not found: ${temp_dir}"
        exit 1
    fi
    
    # Check that required AI analysis files exist
    local required_files=(
        "${temp_dir}/ai-summary.txt"
        "${temp_dir}/ai-impact.txt"
        "${temp_dir}/ai-actions.txt"
        "${temp_dir}/ai-security.txt"
    )
    
    validate_required_files "${required_files[@]}"
}

# Load AI analysis sections from files
load_ai_sections() {
    local temp_dir="$1"
    
    log_process "Loading AI analysis sections..."
    
    SUMMARY=$(read_file "${temp_dir}/ai-summary.txt" "AI summary")
    IMPACT=$(read_file "${temp_dir}/ai-impact.txt" "AI impact analysis")
    ACTIONS=$(read_file "${temp_dir}/ai-actions.txt" "AI recommended actions")
    SECURITY=$(read_file "${temp_dir}/ai-security.txt" "AI security considerations")
    
    log_success "AI analysis sections loaded successfully"
    
    # Log section sizes for debugging
    log_info "Section sizes:"
    log_info "  - Summary: ${#SUMMARY} characters"
    log_info "  - Impact: ${#IMPACT} characters"
    log_info "  - Actions: ${#ACTIONS} characters"
    log_info "  - Security: ${#SECURITY} characters"
}

# Generate the markdown comment file
generate_comment_file() {
    local temp_dir="$1"
    local comment_file="${temp_dir}/comment.md"
    
    log_process "Generating markdown comment..."
    
    # Escape content for safe sed replacement
    local escaped_summary escaped_impact escaped_actions escaped_security
    escaped_summary=$(escape_for_sed "${SUMMARY}")
    escaped_impact=$(escape_for_sed "${IMPACT}")
    escaped_actions=$(escape_for_sed "${ACTIONS}")
    escaped_security=$(escape_for_sed "${SECURITY}")
    
    # Create comment from template with replacements
    create_from_template "${COMMENT_TEMPLATE}" "${comment_file}" \
        "SUMMARY_PLACEHOLDER" "${escaped_summary}" \
        "IMPACT_PLACEHOLDER" "${escaped_impact}" \
        "ACTIONS_PLACEHOLDER" "${escaped_actions}" \
        "SECURITY_PLACEHOLDER" "${escaped_security}"
    
    log_success "Markdown comment generated: ${comment_file}"
    
    # Log comment file size for debugging
    local comment_size
    comment_size=$(get_file_size "${comment_file}")
    log_info "Generated comment size: ${comment_size} characters"
}

# Validate the generated comment file
validate_comment_file() {
    local temp_dir="$1"
    local comment_file="${temp_dir}/comment.md"
    
    log_process "Validating generated comment..."
    
    # Check if comment file exists and is not empty
    if [[ ! -f "${comment_file}" ]]; then
        log_error "Comment file was not created: ${comment_file}"
        create_fallback_comment "${temp_dir}"
        return
    fi
    
    if [[ ! -s "${comment_file}" ]]; then
        log_error "Comment file is empty: ${comment_file}"
        create_fallback_comment "${temp_dir}"
        return
    fi
    
    # Validate file size (should be reasonable for a comment)
    if ! validate_file_size "${comment_file}" 5000; then
        log_warning "Comment file is quite large, but proceeding..."
    fi
    
    # Check that no placeholders remain
    if grep -q "PLACEHOLDER" "${comment_file}"; then
        log_warning "Comment contains unreplaced placeholders"
        # Show which placeholders remain
        local remaining_placeholders
        remaining_placeholders=$(grep -o "[A-Z_]*PLACEHOLDER" "${comment_file}" | sort | uniq | tr '\n' ' ')
        log_warning "Remaining placeholders: ${remaining_placeholders}"
    fi
    
    log_success "Comment validation completed"
}

# Create fallback comment when generation fails
create_fallback_comment() {
    local temp_dir="$1"
    local comment_file="${temp_dir}/comment.md"
    
    log_warning "Creating fallback comment due to generation failure..."
    
    cat > "${comment_file}" << 'EOF'
## 🤖 AI Analysis Summary

AI分析の生成中にエラーが発生しました。手動でPRの内容を確認してください。

### 📋 推奨アクション
- PRの変更内容を手動で確認してください
- 依存関係の更新内容とバージョンをチェックしてください
- テストを実行して動作確認を行ってください
- セキュリティに関する変更がないか確認してください

---
*Generated by GitHub Models AI*
EOF
    
    log_success "Fallback comment created"
}

# Preview comment (for testing/debugging)
preview_comment() {
    local temp_dir="$1"
    local comment_file="${temp_dir}/comment.md"
    
    if [[ -f "${comment_file}" ]]; then
        log_info "Comment preview:"
        echo "----------------------------------------"
        cat "${comment_file}"
        echo "----------------------------------------"
    else
        log_error "Comment file not found for preview: ${comment_file}"
    fi
}

# Get comment file path (for use by other scripts)
get_comment_file_path() {
    local temp_dir="$1"
    echo "${temp_dir}/comment.md"
}

# Validate comment content quality
validate_comment_quality() {
    local temp_dir="$1"
    local comment_file="${temp_dir}/comment.md"
    
    if [[ ! -f "${comment_file}" ]]; then
        log_error "Comment file not found for quality validation"
        return 1
    fi
    
    local word_count line_count
    word_count=$(wc -w < "${comment_file}" | tr -d ' ')
    line_count=$(wc -l < "${comment_file}" | tr -d ' ')
    
    log_info "Comment quality metrics:"
    log_info "  - Word count: ${word_count}"
    log_info "  - Line count: ${line_count}"
    
    # Basic quality checks
    if [[ "${word_count}" -lt 10 ]]; then
        log_warning "Comment seems too short (${word_count} words)"
        return 1
    fi
    
    if [[ "${word_count}" -gt 500 ]]; then
        log_warning "Comment seems too long (${word_count} words)"
    fi
    
    # Check for required sections
    local required_sections=("更新概要" "潜在的な影響とリスク" "推奨アクション" "セキュリティ考慮事項")
    for section in "${required_sections[@]}"; do
        if ! grep -q "${section}" "${comment_file}"; then
            log_warning "Missing section: ${section}"
        fi
    done
    
    log_success "Comment quality validation completed"
    return 0
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    if [[ $# -lt 1 ]]; then
        log_error "Usage: $0 <temp_dir> [preview]"
        exit 1
    fi
    
    main "$1"
    
    # If preview argument is provided, show comment preview
    if [[ "${2:-}" == "preview" ]]; then
        preview_comment "$1"
    fi
fi